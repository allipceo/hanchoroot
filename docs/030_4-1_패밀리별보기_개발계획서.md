# 4단계 패밀리별 보기 기능 개발계획서

**작성일**: 2025년 1월 13일  
**작성자**: 서대리  
**단계**: 4단계 - 패밀리별 보기 기능  
**문서번호**: 4-1

---

## 📋 **개발 개요**

### **목표**
- Line별, 세대별로 가족 구성원을 분류하여 표시하는 기능 구현
- 가족 트리 형태의 시각적 표현으로 가족 관계 파악 용이성 제공
- 실제 노션 데이터 100명을 활용한 완전한 패밀리별 보기 시스템 구축

### **핵심 가치**
- **실용성 우선**: 당장 사용 가능한 기능 구현
- **간결함과 재활용성**: 1-3단계 구조 최대 활용
- **모바일 최적화**: 터치 친화적 인터페이스
- **실제 데이터 기반**: 100명 실제 노션 데이터 활용

---

## 🎯 **기능 명세**

### **4-1: 패밀리별 보기 화면 설계**

#### **화면 구성**
```
┌─────────────────────────────────────┐
│ ← 뒤로  🏠 홈    📱 패밀리별 보기    │
├─────────────────────────────────────┤
│ [Line1] [Line2] [Line3]             │
├─────────────────────────────────────┤
│ [0세대] [4세대] [5세대] [6세대] [전체] │
├─────────────────────────────────────┤
│                                     │
│  👤 조영하 (0세대) 💚               │
│     ├─ 👤 조세희 (5세대) 💚         │
│     └─ 👤 조명하 (0세대) 💚         │
│                                     │
│  👤 조성순 (4세대) 💚               │
│     ├─ 👤 조용희 (5세대) 💚         │
│     └─ 👤 조웅희 (5세대) 💚         │
│                                     │
└─────────────────────────────────────┘
```

#### **UI 컴포넌트**
- **Line 탭**: Line1, Line2, Line3 선택 탭
- **세대 필터**: 0세대, 4세대, 5세대, 6세대, 전체 버튼
- **가족 트리**: 계층 구조로 표시되는 인물 목록
- **상태 아이콘**: 💚(생존), 🙏(고인), ❓(미확인)

### **4-2: 데이터 필터링 로직 구현**

#### **필터링 기능**
- **Line별 필터링**: `searchIndex.byLine` 활용
- **세대별 필터링**: `searchIndex.byGeneration` 활용
- **상태별 필터링**: `searchIndex.byStatus` 활용
- **복합 필터링**: Line + 세대 + 상태 조합

#### **데이터 구조**
```javascript
// 필터링 결과 데이터 구조
const filteredData = {
  line: 'Line1',
  generation: '5',
  status: 'living',
  persons: [
    {
      id: 'G5M001S',
      name: '조세희',
      generation: 5,
      line: 'Line1',
      status: 'living',
      relationships: { father: '조영하', mother: null },
      // ... 기타 정보
    }
  ]
};
```

### **4-3: 가족 트리 시각화**

#### **트리 구조**
- **계층 표시**: 들여쓰기로 세대 구분
- **관계선**: 시각적 연결선 (CSS로 구현)
- **상태 표시**: 아이콘으로 생존/고인/미확인 구분
- **터치 인터랙션**: 인물 클릭 시 상세 정보 표시

#### **반응형 레이아웃**
- **모바일 최적화**: 세로 스크롤, 터치 친화적
- **폰트 크기**: 60세 이상도 쉽게 읽을 수 있는 크기
- **여백**: 터치하기 쉬운 충분한 여백

### **4-4: 통합 테스트 및 최적화**

#### **성능 최적화**
- **지연 로딩**: 필요한 데이터만 로드
- **캐싱**: 필터링 결과 캐시
- **가상 스크롤**: 대량 데이터 처리

#### **호환성 테스트**
- **모바일 브라우저**: iOS Safari, Android Chrome
- **터치 인터랙션**: 탭, 스크롤, 줌
- **성능**: 페이지 로딩 2초 이내

---

## 🔧 **기술 구현**

### **4-1: 패밀리별 보기 화면 설계**

#### **HTML 구조**
```html
<!-- app/family.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>패밀리별 보기 - 한양조씨 족보 앱</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/family.css">
</head>
<body>
    <div id="app">
        <header class="sub-header">
            <button class="back-button" onclick="history.back()">← 뒤로</button>
            <h1>📱 패밀리별 보기</h1>
            <button class="home-button" onclick="location.href='index.html'">🏠 홈</button>
        </header>
        
        <main class="family-main">
            <!-- Line 탭 -->
            <div class="line-tabs">
                <button class="tab-button active" data-line="Line1">Line1</button>
                <button class="tab-button" data-line="Line2">Line2</button>
                <button class="tab-button" data-line="Line3">Line3</button>
            </div>
            
            <!-- 세대 필터 -->
            <div class="generation-filters">
                <button class="filter-button active" data-generation="all">전체</button>
                <button class="filter-button" data-generation="0">0세대</button>
                <button class="filter-button" data-generation="4">4세대</button>
                <button class="filter-button" data-generation="5">5세대</button>
                <button class="filter-button" data-generation="6">6세대</button>
            </div>
            
            <!-- 가족 트리 -->
            <div class="family-tree">
                <div id="familyList" class="family-list">
                    <!-- 가족 트리 내용이 여기에 동적으로 생성됩니다 -->
                </div>
            </div>
        </main>
        
        <footer>
            <p>버전: <span id="app-version"></span> | 데이터: <span id="data-version"></span></p>
        </footer>
    </div>

    <script src="../data/core.js"></script>
    <script src="../js/family.js"></script>
</body>
</html>
```

#### **CSS 스타일링**
```css
/* css/family.css */
.family-main {
    padding: 20px;
}

.line-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    background-color: #fff;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    padding: 10px;
}

.tab-button {
    flex: 1;
    padding: 12px 16px;
    border: none;
    border-radius: 8px;
    background-color: #f0f0f0;
    color: #666;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s;
}

.tab-button.active {
    background-color: var(--primary-color);
    color: #fff;
}

.generation-filters {
    display: flex;
    gap: 8px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.filter-button {
    padding: 8px 16px;
    border: 1px solid #ddd;
    border-radius: 20px;
    background-color: #fff;
    color: #666;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
}

.filter-button.active {
    background-color: var(--secondary-color);
    color: #fff;
    border-color: var(--secondary-color);
}

.family-tree {
    background-color: #fff;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    padding: 20px;
    min-height: 400px;
}

.family-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.family-member {
    display: flex;
    align-items: center;
    padding: 12px;
    border-radius: 8px;
    background-color: #f9f9f9;
    cursor: pointer;
    transition: background-color 0.2s;
}

.family-member:hover {
    background-color: #f0f0f0;
}

.family-member .status-icon {
    font-size: 20px;
    margin-right: 10px;
}

.family-member .member-info {
    flex-grow: 1;
}

.family-member .member-name {
    font-size: 18px;
    font-weight: bold;
    color: var(--text-color);
    margin-bottom: 4px;
}

.family-member .member-details {
    font-size: 14px;
    color: var(--dark-gray);
}

.family-member .generation-badge {
    background-color: var(--primary-color);
    color: #fff;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
}
```

### **4-2: 데이터 필터링 로직 구현**

#### **JavaScript 로직**
```javascript
// js/family.js
let familyData = null;
let currentLine = 'Line1';
let currentGeneration = 'all';

document.addEventListener('DOMContentLoaded', () => {
    initFamilyPage();
});

function initFamilyPage() {
    console.log("Family page initialized.");
    if (typeof coreLoader !== 'undefined') {
        familyData = coreLoader.load();
        displayAppVersion();
        setupFamilyEventListeners();
        renderFamilyTree();
    } else {
        console.error("Core Module을 찾을 수 없습니다.");
    }
}

function setupFamilyEventListeners() {
    // Line 탭 이벤트
    document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', (e) => {
            currentLine = e.target.dataset.line;
            updateTabButtons();
            renderFamilyTree();
        });
    });
    
    // 세대 필터 이벤트
    document.querySelectorAll('.filter-button').forEach(button => {
        button.addEventListener('click', (e) => {
            currentGeneration = e.target.dataset.generation;
            updateFilterButtons();
            renderFamilyTree();
        });
    });
}

function updateTabButtons() {
    document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.toggle('active', button.dataset.line === currentLine);
    });
}

function updateFilterButtons() {
    document.querySelectorAll('.filter-button').forEach(button => {
        button.classList.toggle('active', button.dataset.generation === currentGeneration);
    });
}

function getFilteredPersons() {
    let persons = familyData.persons;
    
    // Line별 필터링
    if (currentLine !== 'all') {
        persons = persons.filter(person => person.line === currentLine);
    }
    
    // 세대별 필터링
    if (currentGeneration !== 'all') {
        const generation = parseInt(currentGeneration);
        persons = persons.filter(person => person.generation === generation);
    }
    
    return persons;
}

function renderFamilyTree() {
    const familyList = document.getElementById('familyList');
    const filteredPersons = getFilteredPersons();
    
    familyList.innerHTML = '';
    
    if (filteredPersons.length === 0) {
        familyList.innerHTML = '<p class="no-results">해당 조건에 맞는 가족 구성원이 없습니다.</p>';
        return;
    }
    
    // 세대별로 그룹화
    const groupedByGeneration = groupByGeneration(filteredPersons);
    
    // 세대 순서대로 정렬하여 렌더링
    const generations = Object.keys(groupedByGeneration).sort((a, b) => parseInt(a) - parseInt(b));
    
    generations.forEach(generation => {
        const generationGroup = document.createElement('div');
        generationGroup.className = 'generation-group';
        
        const generationHeader = document.createElement('h3');
        generationHeader.className = 'generation-header';
        generationHeader.textContent = `${generation}세대 (${groupedByGeneration[generation].length}명)`;
        generationGroup.appendChild(generationHeader);
        
        groupedByGeneration[generation].forEach(person => {
            const memberElement = createFamilyMemberElement(person);
            generationGroup.appendChild(memberElement);
        });
        
        familyList.appendChild(generationGroup);
    });
}

function groupByGeneration(persons) {
    return persons.reduce((groups, person) => {
        const generation = person.generation;
        if (!groups[generation]) {
            groups[generation] = [];
        }
        groups[generation].push(person);
        return groups;
    }, {});
}

function createFamilyMemberElement(person) {
    const memberElement = document.createElement('div');
    memberElement.className = 'family-member';
    memberElement.onclick = () => showPersonDetail(person.id);
    
    const statusIcon = getStatusIcon(person.status);
    const generationBadge = `${person.generation}세대`;
    
    memberElement.innerHTML = `
        <span class="status-icon">${statusIcon}</span>
        <div class="member-info">
            <div class="member-name">${person.name}</div>
            <div class="member-details">${person.line} | ${person.relationships.father ? `아버지: ${person.relationships.father}` : '아버지 정보 없음'}</div>
        </div>
        <span class="generation-badge">${generationBadge}</span>
    `;
    
    return memberElement;
}

function getStatusIcon(status) {
    switch(status) {
        case 'living': return '💚';
        case 'deceased': return '🙏';
        case 'unknown': return '❓';
        default: return '❓';
    }
}

function showPersonDetail(personId) {
    // 상세 정보 화면으로 이동
    window.location.href = `detail.html?id=${personId}`;
}

function displayAppVersion() {
    const appConfig = familyData.config.app;
    document.getElementById('app-version').textContent = appConfig.version;
    document.getElementById('data-version').textContent = appConfig.dataVersion;
}
```

### **4-3: 가족 트리 시각화**

#### **고급 트리 시각화 (선택사항)**
```javascript
// 고급 가족 트리 시각화 함수
function renderAdvancedFamilyTree() {
    const filteredPersons = getFilteredPersons();
    
    // 관계 기반 트리 구조 생성
    const treeStructure = buildFamilyTree(filteredPersons);
    
    // 시각적 트리 렌더링
    renderTreeVisualization(treeStructure);
}

function buildFamilyTree(persons) {
    // 관계 정보를 기반으로 트리 구조 생성
    const tree = {};
    const rootPersons = persons.filter(person => !person.relationships.father);
    
    rootPersons.forEach(root => {
        tree[root.id] = buildSubTree(root, persons);
    });
    
    return tree;
}

function buildSubTree(person, allPersons) {
    const children = allPersons.filter(p => p.relationships.father === person.name);
    
    return {
        person: person,
        children: children.map(child => buildSubTree(child, allPersons))
    };
}
```

### **4-4: 통합 테스트 및 최적화**

#### **성능 최적화**
```javascript
// 성능 최적화를 위한 캐싱
const filterCache = new Map();

function getCachedFilteredPersons(line, generation) {
    const cacheKey = `${line}-${generation}`;
    
    if (filterCache.has(cacheKey)) {
        return filterCache.get(cacheKey);
    }
    
    const result = getFilteredPersons();
    filterCache.set(cacheKey, result);
    
    return result;
}

// 지연 로딩 구현
function lazyLoadFamilyMembers() {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                loadFamilyMember(entry.target);
            }
        });
    });
    
    document.querySelectorAll('.family-member').forEach(member => {
        observer.observe(member);
    });
}
```

---

## 📊 **개발 일정**

### **4-1: 패밀리별 보기 화면 설계** (1시간)
- HTML 구조 설계 및 구현
- CSS 스타일링 및 반응형 레이아웃
- 기본 UI 컴포넌트 구현

### **4-2: 데이터 필터링 로직 구현** (1시간 30분)
- Line별, 세대별 필터링 로직
- 복합 필터링 기능
- 필터링 결과 캐싱

### **4-3: 가족 트리 시각화** (1시간 30분)
- 계층 구조 표시
- 상태 아이콘 및 배지
- 터치 인터랙션 구현

### **4-4: 통합 테스트 및 최적화** (1시간)
- 실제 데이터로 테스트
- 성능 최적화
- 모바일 호환성 확인

**총 예상 소요 시간**: 5시간

---

## 🎯 **성공 기준**

### **기능적 요구사항**
- [ ] Line별 탭으로 가족 구성원 분류 표시
- [ ] 세대별 필터로 인물 필터링
- [ ] 상태별 아이콘으로 생존/고인/미확인 구분
- [ ] 인물 클릭 시 상세 정보 화면 이동
- [ ] 실제 데이터 100명 모두 정상 표시

### **성능 요구사항**
- [ ] 페이지 로딩 시간 2초 이내
- [ ] 필터링 응답 시간 0.5초 이내
- [ ] 모바일에서 부드러운 스크롤
- [ ] 터치 인터랙션 반응성

### **사용성 요구사항**
- [ ] 60세 이상도 쉽게 사용 가능
- [ ] 직관적인 네비게이션
- [ ] 명확한 정보 표시
- [ ] 오류 상황 처리

---

## 🔄 **개발 프로세스**

### **개발 → 시뮬레이션 → 검증 → 실제데이터 테스트 → 디버깅 → 문서화**

1. **개발**: 각 세부 단계별 기능 구현
2. **시뮬레이션**: 샘플 데이터로 기능 테스트
3. **검증**: 코드 품질 및 로직 검증
4. **실제데이터 테스트**: 100명 실제 데이터로 테스트
5. **디버깅**: 발견된 문제점 수정
6. **문서화**: 개발 경과 및 결과 보고서 작성

---

## 📝 **예상 결과물**

### **생성될 파일**
- `app/family.html` - 패밀리별 보기 화면
- `css/family.css` - 패밀리별 보기 스타일
- `js/family.js` - 패밀리별 보기 로직

### **업데이트될 파일**
- `js/app.js` - 메인 화면에서 패밀리별 보기 메뉴 연결

### **기대 효과**
- 가족 구성원을 한눈에 파악 가능
- Line별, 세대별 체계적 분류
- 직관적인 가족 관계 이해
- 모바일에서 편리한 사용성

---

**계획서 작성 완료일**: 2025년 1월 13일  
**승인 대기**: 조대표님 승인 후 개발 진행
