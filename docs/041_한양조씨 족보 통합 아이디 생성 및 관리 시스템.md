# 한양조씨 족보 통합 관리 시스템

**작성일**: 2025.01.14 16:00 KST  
**작성자**: 노팀장  
**대상**: 서대리 (Cursor AI)  
**목적**: ID 생성부터 신규 구성원 추가까지 통합 관리

## 📋 통합 시스템 개요

이 모듈 하나로 모든 족보 관리가 가능합니다:
1. **기존 114명 ID 일괄 생성**
2. **ID 규칙 및 검증**  
3. **신규 구성원 자동 추가**
4. **자연어 명령 처리**
5. **데이터 무결성 관리**

## 💻 통합 족보 관리 시스템

### 핵심 통합 클래스
```javascript
/**
 * 한양조씨 족보 통합 관리 시스템
 * - ID 생성, 기존 데이터 처리, 신규 구성원 추가를 모두 처리
 */
class CompleteFamilySystem {
    constructor() {
        this.members = new Map();           // ID -> 구성원 정보
        this.counters = {};                 // 카테고리별 순번 카운터
        this.changes = [];                  // 변경 이력
        this.nameIndex = new Map();         // 이름 -> ID 매핑 (동명이인 처리)
        
        console.log('🏠 한양조씨 족보 시스템 초기화 완료');
    }
    
    // ========================================
    // 1. ID 생성 규칙 및 기본 함수
    // ========================================
    
    /**
     * 개인 ID 생성
     * @param {string} name - 이름
     * @param {number} generation - 세대 (1-6)
     * @param {string} line - Line (LC/L1/L2/L3)  
     * @param {string} gender - 성별 (M/F)
     * @param {string} relationship - 관계 (son/wife/daughter/husband)
     * @returns {string} 생성된 ID
     */
    generateId(name, generation, line, gender, relationship) {
        // 관계 코드 매핑
        const relationshipMap = {
            'son': 'SM',     // 조씨 아들
            'wife': 'WF',    // 며느리  
            'daughter': 'DF', // 조씨 딸
            'husband': 'HM'   // 사위
        };
        
        // 입력값 검증
        const validLines = ['LC', 'L1', 'L2', 'L3'];
        if (!validLines.includes(line)) {
            throw new Error(`❌ 잘못된 Line: ${line}. 사용 가능: ${validLines.join(', ')}`);
        }
        
        if (generation < 1 || generation > 10) {
            throw new Error(`❌ 잘못된 세대: ${generation}. 범위: 1-10`);
        }
        
        // 세대 코드
        const genCode = `G${generation}`;
        
        // 관계 코드
        const relCode = relationshipMap[relationship.toLowerCase()];
        if (!relCode) {
            throw new Error(`❌ 잘못된 관계: ${relationship}. 사용 가능: ${Object.keys(relationshipMap).join(', ')}`);
        }
        
        // 카테고리 키 생성 (순번 카운터용)
        const categoryKey = `${line}-${genCode}-${relCode}`;
        
        // 순번 증가
        if (!this.counters[categoryKey]) {
            this.counters[categoryKey] = 0;
        }
        this.counters[categoryKey]++;
        
        // 순번을 3자리로 포맷
        const sequence = this.counters[categoryKey].toString().padStart(3, '0');
        
        // 최종 ID 생성
        const id = `${line}-${genCode}-${relCode}-${sequence}`;
        
        console.log(`✅ ID 생성: ${name} → ${id}`);
        return id;
    }
    
    /**
     * ID 파싱
     */
    parseId(id) {
        const parts = id.split('-');
        if (parts.length !== 4) {
            throw new Error(`❌ 잘못된 ID 형식: ${id}`);
        }
        
        const [line, generation, relationship, sequence] = parts;
        
        const relationshipName = {
            'SM': '조씨 아들',
            'WF': '며느리',
            'DF': '조씨 딸', 
            'HM': '사위'
        };
        
        return {
            line: line,
            generation: parseInt(generation.replace('G', '')),
            relationship: relationship,
            relationshipName: relationshipName[relationship],
            sequence: parseInt(sequence),
            isJoFamily: ['SM', 'DF'].includes(relationship) // 조씨 혈통 여부
        };
    }
    
    /**
     * 배우자 ID 찾기
     */
    findSpouseIdPattern(personId) {
        const parts = personId.split('-');
        if (parts.length !== 4) return null;
        
        const [line, gen, rel, seq] = parts;
        
        // 배우자 관계 코드 매핑
        const spouseMap = {
            'SM': 'WF', // 조씨 남자 → 며느리
            'WF': 'SM', // 며느리 → 조씨 남자  
            'DF': 'HM', // 조씨 딸 → 사위
            'HM': 'DF'  // 사위 → 조씨 딸
        };
        
        const spouseRel = spouseMap[rel];
        return spouseRel ? `${line}-${gen}-${spouseRel}-${seq}` : null;
    }
    
    // ========================================
    // 2. 기존 데이터 처리 (114명 일괄 적용)
    // ========================================
    
    /**
     * 기존 노션 데이터에 ID 일괄 생성 및 적용
     * @param {Array} notionData - 노션에서 가져온 원본 데이터
     * @returns {Array} ID가 부여된 완전한 데이터
     */
    applyIdsToExistingData(notionData) {
        console.log(`🔄 기존 데이터 ${notionData.length}명 ID 생성 시작...`);
        
        const results = [];
        let successCount = 0;
        let errorCount = 0;
        
        // 세대순으로 정렬 (1세대부터 처리)
        const sortedData = notionData.sort((a, b) => a.세대 - b.세대);
        
        sortedData.forEach((person, index) => {
            try {
                const line = this.determinePersonLine(person);
                const relationship = this.determineRelationship(person);
                const gender = person.성별 || this.determineGender(person.이름);
                
                const id = this.generateId(
                    person.이름,
                    person.세대,
                    line,
                    gender,
                    relationship
                );
                
                // 완전한 구성원 정보 생성
                const completeMember = {
                    id: id,
                    name: person.이름,
                    gender: gender,
                    generation: person.세대,
                    line: line,
                    relationship: relationship,
                    birthYear: person.생년 || null,
                    status: this.determineStatus(person),
                    deathYear: person.사망일 || null,
                    fatherName: person.아버지 || null,
                    motherName: person.어머니 || null,
                    spouseName: person.배우자 || null,
                    children: [],
                    phone: person.연락처 || '',
                    address: person.주소 || '',
                    job: person.직업 || '',
                    notes: person.비고 || '',
                    originalData: person, // 원본 데이터 보존
                    createdAt: new Date().toISOString()
                };
                
                // 메모리에 저장
                this.members.set(id, completeMember);
                
                // 이름 인덱스 업데이트 (동명이인 처리용)
                this.updateNameIndex(completeMember.name, id);
                
                results.push(completeMember);
                successCount++;
                
            } catch (error) {
                console.error(`❌ ID 생성 실패 - ${person.이름}:`, error.message);
                errorCount++;
                
                // 오류 정보도 결과에 포함
                results.push({
                    ...person,
                    id: null,
                    error: error.message
                });
            }
        });
        
        console.log(`✅ 기존 데이터 처리 완료: 성공 ${successCount}명, 실패 ${errorCount}명`);
        
        // 가족 관계 연결 (부모-자녀, 배우자 관계)
        this.linkFamilyRelationships();
        
        return results;
    }
    
    /**
     * Line 결정 로직
     */
    determinePersonLine(person) {
        if (person.세대 <= 2) return 'LC';
        
        // Line 정보가 있는 경우
        if (person.Line) {
            if (person.Line === 'Line1') return 'L1';
            if (person.Line === 'Line2') return 'L2';  
            if (person.Line === 'Line3') return 'L3';
        }
        
        // Line 정보가 없는 경우 부모를 통해 추정
        return this.inferLineFromParents(person);
    }
    
    /**
     * 관계 결정 로직  
     */
    determineRelationship(person) {
        const name = person.이름;
        const gender = person.성별 || this.determineGender(name);
        
        if (name.startsWith('조')) {
            return gender === 'M' ? 'son' : 'daughter';
        } else {
            return gender === 'F' ? 'wife' : 'husband';
        }
    }
    
    /**
     * 성별 자동 추론
     */
    determineGender(name) {
        return name.startsWith('조') ? 'M' : 'F';
    }
    
    /**
     * 생존 상태 결정
     */
    determineStatus(person) {
        if (person.사망일 || person.생존상태 === '고인') return 'deceased';
        if (person.세대 <= 2) return 'deceased'; // 1-2세대는 대부분 고인
        if (person.세대 >= 5) return 'living';   // 5-6세대는 대부분 생존
        return person.생존상태 || 'unknown';
    }
    
    /**
     * 이름 인덱스 업데이트 (동명이인 처리)
     */
    updateNameIndex(name, id) {
        if (!this.nameIndex.has(name)) {
            this.nameIndex.set(name, []);
        }
        this.nameIndex.get(name).push(id);
    }
    
    // ========================================
    // 3. 신규 구성원 자동 추가
    // ========================================
    
    /**
     * 자연어 입력으로 신규 구성원 추가
     * @param {string} input - "조대하-허효순 사이에 아들 조성민이 태어났습니다"
     * @returns {Object} 생성된 구성원 정보
     */
    addNewMemberFromText(input) {
        console.log(`🔄 자연어 처리: ${input}`);
        
        const parsed = this.parseNaturalLanguage(input);
        return this.addNewMember(
            parsed.name,
            parsed.fatherId, 
            parsed.motherId,
            parsed.gender,
            parsed.birthYear
        );
    }
    
    /**
     * 구조화된 정보로 신규 구성원 추가
     */
    addNewMember(name, fatherId, motherId, gender, birthYear = null) {
        // 부모 정보 검증
        const father = this.members.get(fatherId);
        const mother = this.members.get(motherId);
        
        if (!father || !mother) {
            throw new Error(`❌ 부모 정보를 찾을 수 없습니다: 아버지=${fatherId}, 어머니=${motherId}`);
        }
        
        console.log(`👨‍👩‍👧‍👦 부모: ${father.name}(${fatherId}) + ${mother.name}(${motherId})`);
        
        // Line과 세대 자동 계산
        const line = this.calculateChildLine(father, mother);
        const generation = Math.max(father.generation, mother.generation) + 1;
        
        // 관계 결정
        const relationship = this.determineChildRelationship(name, gender);
        
        // ID 생성
        const id = this.generateId(name, generation, line, gender, relationship);
        
        // 구성원 정보 생성
        const newMember = {
            id: id,
            name: name,
            gender: gender,
            generation: generation,
            line: line,
            relationship: relationship,
            birthYear: birthYear,
            status: 'living',
            fatherId: fatherId,
            motherId: motherId,
            children: [],
            phone: '',
            address: '',
            job: '',
            notes: `자동 생성 (${new Date().toLocaleDateString()})`,
            createdAt: new Date().toISOString()
        };
        
        // 메모리에 추가
        this.members.set(id, newMember);
        this.updateNameIndex(name, id);
        
        // 부모의 자녀 목록에 추가
        father.children = father.children || [];
        mother.children = mother.children || [];
        father.children.push(id);
        mother.children.push(id);
        
        // 변경 로그 기록
        this.changes.push({
            type: 'birth',
            member: newMember,
            parents: [father.name, mother.name],
            timestamp: new Date(),
            description: `${name} 출생 (부모: ${father.name}-${mother.name})`
        });
        
        console.log(`✅ 신규 구성원 추가 완료: ${name} → ${id}`);
        return newMember;
    }
    
    /**
     * 결혼 정보 추가
     */
    addMarriage(personId, spouseName, spouseGender, marriageYear = null) {
        const person = this.members.get(personId);
        if (!person) {
            throw new Error(`❌ 사람을 찾을 수 없습니다: ${personId}`);
        }
        
        // 배우자 관계 결정
        const spouseRelationship = person.relationship === 'son' ? 'wife' : 
                                 person.relationship === 'daughter' ? 'husband' : 'unknown';
        
        if (spouseRelationship === 'unknown') {
            throw new Error(`❌ ${person.name}의 결혼 상대 관계를 결정할 수 없습니다`);
        }
        
        // 배우자 ID 생성
        const spouseId = this.generateSpouseId(personId, spouseRelationship);
        
        // 배우자 정보 생성
        const spouse = {
            id: spouseId,
            name: spouseName,
            gender: spouseGender,
            generation: person.generation,
            line: person.line,
            relationship: spouseRelationship,
            spouseId: personId,
            marriageYear: marriageYear,
            status: 'living',
            children: [],
            phone: '',
            address: '',
            job: '',
            notes: `결혼 (${marriageYear || '연도미상'})`,
            createdAt: new Date().toISOString()
        };
        
        // 양쪽 배우자 정보 업데이트
        person.spouseId = spouseId;
        person.marriageYear = marriageYear;
        
        this.members.set(spouseId, spouse);
        this.updateNameIndex(spouseName, spouseId);
        
        // 변경 로그 기록
        this.changes.push({
            type: 'marriage',
            couple: [person.name, spouseName],
            timestamp: new Date(),
            description: `${person.name} ♥ ${spouseName} 결혼`
        });
        
        console.log(`💒 결혼 추가 완료: ${person.name} ♥ ${spouseName}`);
        return spouse;
    }
    
    // ========================================
    // 4. 통합 명령어 처리 인터페이스
    // ========================================
    
    /**
     * 자연어 명령어 통합 처리
     * @param {string} command - 자연어 명령
     * @returns {Object} 처리 결과
     */
    processCommand(command) {
        const cmd = command.toLowerCase().trim();
        
        console.log(`🎯 명령어 처리: ${command}`);
        
        try {
            if (cmd.includes('태어났습니다') || cmd.includes('출생')) {
                return this.handleBirth(command);
            } else if (cmd.includes('결혼')) {
                return this.handleMarriage(command);
            } else if (cmd.includes('사망') || cmd.includes('별세')) {
                return this.handleDeath(command);
            } else if (cmd.includes('검색') || cmd.includes('찾아')) {
                return this.handleSearch(command);
            } else if (cmd.includes('목록') || cmd.includes('전체')) {
                return this.handleList(command);
            } else {
                return this.handleDirectInput(command);
            }
        } catch (error) {
            console.error('❌ 명령어 처리 실패:', error.message);
            return {
                success: false,
                error: error.message,
                suggestion: this.getSuggestion(command)
            };
        }
    }
    
    /**
     * 출생 처리
     */
    handleBirth(command) {
        const newMember = this.addNewMemberFromText(command);
        
        return {
            success: true,
            type: 'birth',
            member: newMember,
            message: `🎉 ${newMember.name}(${newMember.id})이 족보에 추가되었습니다!`,
            summary: {
                name: newMember.name,
                id: newMember.id,
                generation: `${newMember.generation}세대`,
                line: newMember.line,
                parents: this.getParentNames(newMember)
            }
        };
    }
    
    /**
     * 검색 처리
     */
    handleSearch(command) {
        const nameMatch = command.match(/([가-힣]{2,4})/);
        if (!nameMatch) {
            throw new Error('검색할 이름을 찾을 수 없습니다');
        }
        
        const searchName = nameMatch[1];
        const results = this.searchByName(searchName);
        
        return {
            success: true,
            type: 'search',
            query: searchName,
            results: results,
            message: `🔍 "${searchName}" 검색 결과: ${results.length}명`,
            hasMultiple: results.length > 1
        };
    }
    
    // ========================================
    // 5. 유틸리티 및 조회 함수
    // ========================================
    
    /**
     * 이름으로 검색 (동명이인 포함)
     */
    searchByName(name) {
        const ids = this.nameIndex.get(name) || [];
        return ids.map(id => {
            const member = this.members.get(id);
            const parents = this.getParentNames(member);
            const spouse = member.spouseId ? this.members.get(member.spouseId) : null;
            
            return {
                ...member,
                parents: parents,
                spouseName: spouse ? spouse.name : null,
                displayName: `${member.name} (${member.generation}세대, ${member.line})`
            };
        });
    }
    
    /**
     * 부모 이름 조회
     */
    getParentNames(member) {
        const father = member.fatherId ? this.members.get(member.fatherId) : null;
        const mother = member.motherId ? this.members.get(member.motherId) : null;
        
        return {
            father: father ? father.name : member.fatherName || '미확인',
            mother: mother ? mother.name : member.motherName || '미확인'
        };
    }
    
    /**
     * 전체 구성원 목록 (정렬된)
     */
    getAllMembers() {
        return Array.from(this.members.values())
                   .sort((a, b) => a.id.localeCompare(b.id));
    }
    
    /**
     * 세대별 구성원 조회
     */
    getMembersByGeneration(generation) {
        return Array.from(this.members.values())
                   .filter(member => member.generation === generation)
                   .sort((a, b) => a.id.localeCompare(b.id));
    }
    
    /**
     * Line별 구성원 조회  
     */
    getMembersByLine(line) {
        return Array.from(this.members.values())
                   .filter(member => member.line === line)
                   .sort((a, b) => a.id.localeCompare(b.id));
    }
    
    /**
     * 부부 단위 그룹핑
     */
    getCouples() {
        const couples = [];
        const processed = new Set();
        
        this.members.forEach((person, id) => {
            if (processed.has(id)) return;
            
            const spousePattern = this.findSpouseIdPattern(id);
            if (spousePattern && this.members.has(spousePattern)) {
                const spouse = this.members.get(spousePattern);
                
                couples.push({
                    husband: person.relationship === 'son' ? person : spouse,
                    wife: person.relationship === 'wife' ? person : spouse,
                    generation: person.generation,
                    line: person.line
                });
                
                processed.add(id);
                processed.add(spousePattern);
            }
        });
        
        return couples.sort((a, b) => a.husband.id.localeCompare(b.husband.id));
    }
    
    /**
     * 변경 이력 조회
     */
    getChangeHistory(limit = 10) {
        return this.changes
                   .slice(-limit)
                   .reverse()
                   .map(change => ({
                       ...change,
                       timeAgo: this.getTimeAgo(change.timestamp)
                   }));
    }
    
    /**
     * 통계 정보
     */
    getStatistics() {
        const members = Array.from(this.members.values());
        
        const stats = {
            총인원: members.length,
            세대별: {},
            Line별: {},
            생존현황: {},
            조씨혈통: 0,
            최근변경: this.changes.length
        };
        
        // 세대별 통계
        for (let g = 1; g <= 6; g++) {
            stats.세대별[`${g}세대`] = members.filter(m => m.generation === g).length;
        }
        
        // Line별 통계
        ['LC', 'L1', 'L2', 'L3'].forEach(line => {
            stats.Line별[line] = members.filter(m => m.line === line).length;
        });
        
        // 생존 현황
        ['living', 'deceased', 'unknown'].forEach(status => {
            stats.생존현황[status] = members.filter(m => m.status === status).length;
        });
        
        // 조씨 혈통
        stats.조씨혈통 = members.filter(m => ['son', 'daughter'].includes(m.relationship)).length;
        
        return stats;
    }
    
    // ========================================
    // 6. 내부 유틸리티 함수
    // ========================================
    
    /**
     * 자연어 파싱
     */
    parseNaturalLanguage(input) {
        const patterns = [
            {
                regex: /(\w+)-(\w+)\s*사이에\s*(아들|딸)\s*(\w+).*?(\d{4})?/,
                extract: (match) => ({
                    fatherName: match[1],
                    motherName: match[2], 
                    genderText: match[3],
                    name: match[4],
                    gender: match[3] === '아들' ? 'M' : 'F',
                    birthYear: match[5] ? parseInt(match[5]) : null
                })
            },
            {
                regex: /(\w+)\((남|여|아들|딸),\s*(\w+)-(\w+)\)/,
                extract: (match) => ({
                    name: match[1],
                    gender: ['남', '아들'].includes(match[2]) ? 'M' : 'F',
                    fatherName: match[3],
                    motherName: match[4]
                })
            }
        ];
        
        for (let pattern of patterns) {
            const match = input.match(pattern.regex);
            if (match) {
                const extracted = pattern.extract(match);
                
                const fatherId = this.findPersonByName(extracted.fatherName);
                const motherId = this.findPersonByName(extracted.motherName);
                
                return {
                    name: extracted.name,
                    fatherId: fatherId,
                    motherId: motherId,
                    gender: extracted.gender,
                    birthYear: extracted.birthYear
                };
            }
        }
        
        throw new Error(`❌ 파싱할 수 없는 입력: ${input}\n💡 예시: "조대하-허효순 사이에 아들 조성민이 태어났습니다"`);
    }
    
    /**
     * 이름으로 사람 찾기 (동명이인 처리)
     */
    findPersonByName(name) {
        const ids = this.nameIndex.get(name);
        if (!ids || ids.length === 0) {
            throw new Error(`❌ 이름을 찾을 수 없습니다: ${name}`);
        }
        
        if (ids.length === 1) {
            return ids[0];
        }
        
        // 동명이인인 경우 - 가장 높은 세대 우선
        const candidates = ids.map(id => this.members.get(id))
                              .sort((a, b) => a.generation - b.generation);
        
        console.log(`⚠️  동명이인 발견 "${name}": ${candidates.length}명. 최상위 세대(${candidates[0].generation}세대) 선택`);
        return candidates[0].id;
    }
    
    getTimeAgo(timestamp) {
        const minutes = Math.floor((new Date() - timestamp) / 60000);
        if (minutes < 1) return '방금 전';
        if (minutes < 60) return `${minutes}분 전`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}시간 전`;
        const days = Math.floor(hours / 24);
        return `${days}일 전`;
    }
    
    calculateChildLine(father, mother) {
        return father.name.startsWith('조') ? father.line : mother.line;
    }
    
    determineChildRelationship(name, gender) {
        return name.startsWith('조') ? 
               (gender === 'M' ? 'son' : 'daughter') : 
               (gender === 'M' ? 'husband' : 'wife');
    }
    
    generateSpouseId(personId, spouseRelationship) {
        const parsed = this.parseId(personId);
        const relationCode = spouseRelationship === 'wife' ? 'WF' : 'HM';
        return `${parsed.line}-G${parsed.generation}-${relationCode}-${parsed.sequence.toString().padStart(3, '0')}`;
    }
    
    linkFamilyRelationships() {
        // TODO: 부모-자녀 관계 자동 연결 로직
        console.log('🔗 가족 관계 연결 작업 시작...');
    }
    
    inferLineFromParents(person) {
        // TODO: 부모 정보로부터 Line 추정 로직
        return 'L1'; // 기본값
    }
    
    getSuggestion(command) {
        return [
            "💡 사용 가능한 명령어:",
            "• '조대하-허효순 사이에 아들 조성민이 태어났습니다'",
            "• '조성민이 김미영과 결혼했습니다'",
            "• '조광희 검색해줘'",
            "• '전체 목록 보여줘'",
            "• '3세대 목록 보여줘'"
        ];
    }
}

// ========================================
// 7. 사용 예시 및 테스트 코드
// ========================================

/**
 * 실제 사용 예시
 */
function demonstrateSystem() {
    console.log('🚀 한양조씨 족보 시스템 데모 시작');
    
    // 시스템 초기화
    const familySystem = new CompleteFamilySystem();
    
    // 1. 기존 노션 데이터 예시 (실제로는 114명)
    const sampleNotionData = [
        {
            이름: '조정윤',
            세대: 1,
            Line: 'Common',
            성별: 'M',
            생년: 1852,
            생존상태: '고인',
            사망일: 1940,
            배우자: '임정숙,이천경',
            비고: '시조'
        },
        {
            이름: '임정숙',
            세대: 1,
            Line: 'Common',
            성별: 'F',
            생년: 1855,
            생존상태: '고인',
            배우자: '조정윤',
            비고: '조정윤 첫째 부인'
        },
        {
            이름: '조대하',
            세대: 3,
            Line: 'Line1',
            성별: 'M',
            생년: 1920,
            생존상태: '생존',
            배우자: '허효순',
            아버지: '조병희',
            어머니: '강부인'
        },
        {
            이름: '허효순',
            세대: 3,
            Line: 'Line1',
            성별: 'F',
            생년: 1925,
            생존상태: '생존',
            배우자: '조대하'
        }
    ];
    
    // 2. 기존 데이터에 ID 적용
    console.log('\n📋 1단계: 기존 데이터 ID 생성');
    const processedData = familySystem.applyIdsToExistingData(sampleNotionData);
    
    processedData.forEach(member => {
        if (member.id) {
            console.log(`✅ ${member.name}: ${member.id}`);
        } else {
            console.log(`❌ ${member.name}: 생성 실패 - ${member.error}`);
        }
    });
    
    // 3. 신규 구성원 자동 추가
    console.log('\n👶 2단계: 신규 구성원 추가');
    
    try {
        // 자연어로 자녀 추가
        const result1 = familySystem.processCommand(
            "조대하-허효순 사이에 아들 조성민이 2010년에 태어났습니다"
        );
        console.log('결과1:', result1.message);
        
        // 딸 추가
        const result2 = familySystem.processCommand(
            "조대하-허효순 사이에 딸 조성희가 2012년에 태어났습니다"
        );
        console.log('결과2:', result2.message);
        
        // 결혼 추가
        const result3 = familySystem.processCommand(
            "조성민이 김미영과 2035년에 결혼했습니다"
        );
        console.log('결과3:', result3.message);
        
    } catch (error) {
        console.error('❌ 신규 추가 실패:', error.message);
    }
    
    // 4. 검색 기능
    console.log('\n🔍 3단계: 검색 기능');
    const searchResult = familySystem.processCommand("조대하 검색해줘");
    console.log('검색 결과:', searchResult);
    
    // 5. 통계 정보
    console.log('\n📊 4단계: 통계 정보');
    const stats = familySystem.getStatistics();
    console.log('족보 통계:', stats);
    
    // 6. 변경 이력
    console.log('\n📝 5단계: 변경 이력');
    const history = familySystem.getChangeHistory();
    history.forEach(change => {
        console.log(`${change.timeAgo}: ${change.description}`);
    });
    
    console.log('\n✅ 데모 완료!');
    return familySystem;
}

// ========================================
// 8. 서대리용 퀵 가이드
// ========================================

/**
 * 서대리용 단계별 사용 가이드
 */
function quickStartGuide() {
    console.log(`
🎯 서대리용 족보 시스템 사용법

1️⃣ 시스템 초기화:
   const family = new CompleteFamilySystem();

2️⃣ 기존 114명 데이터 처리:
   const result = family.applyIdsToExistingData(notionData);

3️⃣ 신규 구성원 추가:
   family.processCommand("조대하-허효순 사이에 아들 조성민이 태어났습니다");

4️⃣ 검색하기:
   family.processCommand("조윤희 검색해줘");

5️⃣ 통계 보기:
   const stats = family.getStatistics();

6️⃣ 모든 구성원 보기:
   const all = family.getAllMembers();

🔧 주요 메서드:
• generateId() - ID 생성
• addNewMember() - 신규 구성원 추가  
• searchByName() - 이름 검색
• getCouples() - 부부 단위 조회
• getChangeHistory() - 변경 이력
• getStatistics() - 통계 정보

💡 ID 형식: L1-G3-SM-001
   L1(Line) G3(세대) SM(관계) 001(순번)
`);
}

// ========================================
// 9. 에러 처리 및 검증
// ========================================

/**
 * 시스템 검증 함수
 */
function validateSystem(familySystem) {
    console.log('🔍 시스템 검증 시작...');
    
    const issues = [];
    
    // ID 중복 검사
    const allIds = Array.from(familySystem.members.keys());
    const uniqueIds = new Set(allIds);
    if (allIds.length !== uniqueIds.size) {
        issues.push('❌ ID 중복 발견');
    }
    
    // 부부 매칭 검사
    familySystem.members.forEach((member, id) => {
        if (member.spouseId) {
            const spouse = familySystem.members.get(member.spouseId);
            if (!spouse || spouse.spouseId !== id) {
                issues.push(`❌ 부부 매칭 오류: ${member.name}(${id})`);
            }
        }
    });
    
    // 부모-자녀 관계 검사
    familySystem.members.forEach((member, id) => {
        if (member.fatherId) {
            const father = familySystem.members.get(member.fatherId);
            if (!father) {
                issues.push(`❌ 아버지 ID 오류: ${member.name} → ${member.fatherId}`);
            }
        }
    });
    
    if (issues.length === 0) {
        console.log('✅ 시스템 검증 통과!');
    } else {
        console.log('⚠️ 검증 이슈:');
        issues.forEach(issue => console.log(issue));
    }
    
    return issues.length === 0;
}

// ========================================
// 10. 내보내기 및 백업
// ========================================

/**
 * JSON 데이터 내보내기
 */
function exportToJSON(familySystem) {
    const exportData = {
        version: "1.0",
        exportDate: new Date().toISOString(),
        totalMembers: familySystem.members.size,
        members: Array.from(familySystem.members.values()),
        statistics: familySystem.getStatistics(),
        changeHistory: familySystem.getChangeHistory(100)
    };
    
    return JSON.stringify(exportData, null, 2);
}

/**
 * CSV 형태로 내보내기
 */
function exportToCSV(familySystem) {
    const members = familySystem.getAllMembers();
    const headers = [
        'ID', '이름', '성별', '세대', 'Line', '관계', 
        '출생년', '생존상태', '아버지', '어머니', '배우자', 
        '연락처', '주소', '직업', '비고'
    ];
    
    const rows = members.map(member => [
        member.id,
        member.name,
        member.gender === 'M' ? '남' : '여',
        `${member.generation}세대`,
        member.line,
        member.relationship,
        member.birthYear || '',
        member.status === 'living' ? '생존' : member.status === 'deceased' ? '고인' : '미확인',
        member.fatherName || '',
        member.motherName || '',
        member.spouseName || '',
        member.phone || '',
        member.address || '',
        member.job || '',
        member.notes || ''
    ]);
    
    return [headers, ...rows]
        .map(row => row.map(cell => `"${cell}"`).join(','))
        .join('\n');
}

// 시스템 테스트 실행
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { 
        CompleteFamilySystem, 
        demonstrateSystem, 
        quickStartGuide,
        validateSystem,
        exportToJSON,
        exportToCSV
    };
} else {
    // 브라우저 환경에서 자동 실행
    console.log('🏠 한양조씨 족보 시스템 로드 완료');
}