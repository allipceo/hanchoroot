# 촌수계산 기능 개발계획서

**문서 번호**: 054  
**작성일**: 2025년 9월 14일  
**작성자**: 서대리  
**프로젝트**: 한양조씨 족보 앱 - 촌수계산 기능 개발  
**개발 방침**: 기존 시스템 활용, 단계별 개발, 완료 체크  

---

## 1. 프로젝트 개요

### 1.1 개발 목표
- **촌수계산 기능**: 두 사람 간의 촌수 관계를 자동으로 계산하여 표시
- **관계도 표시**: 촌수 관계를 시각적으로 표현
- **기존 시스템 활용**: window.CORE_DATA 기반, 기존 함수 재활용

### 1.2 핵심 원칙
- ✅ **window.CORE_DATA 단일 소스**: 기존 데이터 구조 활용
- ✅ **기존 함수 재활용**: 검증된 코드 최대한 활용
- ✅ **기존 프로그램 무영향**: 독립적 모듈로 개발
- ✅ **GIA_KEY_01 사용**: 검증된 API 키 활용
- ✅ **단계별 개발**: 체계적 접근으로 안정성 확보

---

## 2. 촌수계산 알고리즘 설계

### 2.1 촌수 계산 로직
```
촌수 = 공통 조상까지의 거리 합
- 직계: 부모-자식 = 1촌
- 방계: 형제 = 2촌, 사촌 = 4촌, 육촌 = 6촌
- 인척: 배우자 = 0촌 (동일 세대)
```

### 2.2 관계 유형 분류
1. **직계 관계**: 부모-자식, 조부모-손자
2. **방계 관계**: 형제, 사촌, 육촌
3. **인척 관계**: 배우자, 시부모-며느리
4. **복합 관계**: 형수-시누이, 처남-매부

### 2.3 계산 알고리즘
```javascript
function calculateChonsu(person1, person2) {
  // 1. 공통 조상 찾기
  // 2. 각자에서 공통 조상까지의 거리 계산
  // 3. 거리 합산으로 촌수 계산
  // 4. 관계 유형 분류
}
```

---

## 3. 개발 단계별 계획

### 3.1 1단계: 기반 구조 구축
#### 3.1.1 데이터 구조 분석 및 확장
- [ ] **1.1.1** window.CORE_DATA 구조 분석
- [ ] **1.1.2** 관계 데이터 검증 및 보완
- [ ] **1.1.3** ID 기반 관계 매핑 테이블 생성
- [ ] **1.1.4** 테스트용 샘플 데이터 준비

#### 3.1.2 핵심 함수 개발
- [ ] **1.2.1** 공통 조상 찾기 함수 (`findCommonAncestor`)
- [ ] **1.2.2** 조상까지 거리 계산 함수 (`calculateDistanceToAncestor`)
- [ ] **1.2.3** 촌수 계산 메인 함수 (`calculateChonsu`)
- [ ] **1.2.4** 관계 유형 분류 함수 (`classifyRelationship`)

### 3.2 2단계: 촌수계산 엔진 개발
#### 3.2.1 기본 촌수 계산
- [ ] **2.1.1** 직계 관계 촌수 계산 (1촌, 2촌, 3촌)
- [ ] **2.1.2** 방계 관계 촌수 계산 (2촌, 4촌, 6촌)
- [ ] **2.1.3** 인척 관계 촌수 계산 (0촌, 1촌)
- [ ] **2.1.4** 복합 관계 촌수 계산

#### 3.2.2 예외 상황 처리
- [ ] **2.2.1** 관계 데이터 부족 시 처리
- [ ] **2.2.2** 순환 참조 방지
- [ ] **2.2.3** 무한 루프 방지
- [ ] **2.2.4** 오류 로깅 및 예외 처리

### 3.3 3단계: 사용자 인터페이스 개발
#### 3.3.1 촌수계산 입력 인터페이스
- [ ] **3.1.1** 두 사람 선택 UI (드롭다운 또는 검색)
- [ ] **3.1.2** 촌수계산 버튼 및 실행 UI
- [ ] **3.1.3** 결과 표시 영역 설계
- [ ] **3.1.4** 로딩 상태 및 진행률 표시

#### 3.3.2 결과 표시 인터페이스
- [ ] **3.2.1** 촌수 결과 표시 (예: "4촌")
- [ ] **3.2.2** 관계 유형 표시 (예: "사촌")
- [ ] **3.2.3** 관계도 시각화 (선택사항)
- [ ] **3.2.4** 상세 정보 모달 또는 팝업

### 3.4 4단계: 통합 및 테스트
#### 3.4.1 기존 시스템 통합
- [ ] **4.1.1** 개인검색 기능과 연동
- [ ] **4.1.2** 패밀리별 보기와 연동
- [ ] **4.1.3** 기존 네비게이션에 촌수계산 메뉴 추가
- [ ] **4.1.4** CSS/스타일 통합

#### 3.4.2 기능 테스트
- [ ] **4.2.1** 단위 테스트 (각 함수별)
- [ ] **4.2.2** 통합 테스트 (전체 플로우)
- [ ] **4.2.3** 사용자 시나리오 테스트
- [ ] **4.2.4** 성능 테스트 (대용량 데이터)

### 3.5 5단계: 시뮬레이션 및 검증
#### 3.5.1 실제 데이터 시뮬레이션
- [ ] **5.1.1** 152명 데이터로 촌수계산 테스트
- [ ] **5.1.2** 다양한 관계 유형별 테스트
- [ ] **5.1.3** 경계 케이스 테스트
- [ ] **5.1.4** 결과 정확성 검증

#### 3.5.2 사용자 검증
- [ ] **5.2.1** 조대표님 직접 테스트
- [ ] **5.2.2** 실제 가족 관계로 검증
- [ ] **5.2.3** 사용성 테스트
- [ ] **5.2.4** 피드백 수집 및 반영

### 3.6 6단계: 최적화 및 문서화
#### 3.6.1 성능 최적화
- [ ] **6.1.1** 계산 속도 최적화
- [ ] **6.1.2** 메모리 사용량 최적화
- [ ] **6.1.3** 캐싱 시스템 구현
- [ ] **6.1.4** 코드 리팩토링

#### 3.6.2 문서화
- [ ] **6.2.1** 개발 완료 보고서 작성
- [ ] **6.2.2** 사용자 매뉴얼 작성
- [ ] **6.2.3** 기술 문서 작성
- [ ] **6.2.4** 유지보수 가이드 작성

---

## 4. 기술적 구현 사항

### 4.1 사용할 기존 자산
- **데이터 소스**: `window.CORE_DATA` (152명 데이터)
- **API 키**: GIA_KEY_01 (검증된 키)
- **기존 함수**: 검색, 필터링, 데이터 처리 함수들
- **UI 컴포넌트**: 카드, 모달, 버튼 등 기존 컴포넌트

### 4.2 새로 개발할 모듈
```javascript
// 촌수계산 모듈 구조
const ChonsuCalculator = {
  // 핵심 계산 함수들
  findCommonAncestor: function(person1, person2) { },
  calculateDistance: function(person, ancestor) { },
  calculateChonsu: function(person1, person2) { },
  classifyRelationship: function(chonsu, relationship) { },
  
  // UI 관련 함수들
  renderInputForm: function() { },
  renderResult: function(result) { },
  renderRelationshipDiagram: function(relationship) { }
};
```

### 4.3 데이터 구조 확장
```javascript
// window.CORE_DATA에 추가할 필드 (필요시)
{
  // 기존 필드들...
  relationships: {
    // 기존 관계 필드들...
    chonsuCache: {}, // 촌수 계산 결과 캐시
    ancestorTree: [] // 조상 트리 구조
  }
}
```

---

## 5. 개발 일정 및 마일스톤

### 5.1 개발 일정 (예상)
- **1단계**: 2일 (기반 구조 구축)
- **2단계**: 3일 (촌수계산 엔진)
- **3단계**: 2일 (사용자 인터페이스)
- **4단계**: 2일 (통합 및 테스트)
- **5단계**: 2일 (시뮬레이션 및 검증)
- **6단계**: 1일 (최적화 및 문서화)

**총 예상 기간**: 12일

### 5.2 주요 마일스톤
- **M1**: 촌수계산 알고리즘 완성
- **M2**: 기본 UI 구현 완료
- **M3**: 기존 시스템과 통합 완료
- **M4**: 실제 데이터 검증 완료
- **M5**: 최종 배포 준비 완료

---

## 6. 위험 요소 및 대응 방안

### 6.1 기술적 위험
- **복잡한 관계 데이터**: 관계 데이터 부족 또는 오류
  - *대응*: 데이터 검증 및 보완 로직 구현
- **성능 문제**: 대용량 데이터 처리 시 속도 저하
  - *대응*: 캐싱 및 최적화 알고리즘 적용
- **알고리즘 복잡성**: 촌수 계산 로직의 복잡성
  - *대응*: 단계별 테스트 및 검증

### 6.2 사용자 경험 위험
- **UI 복잡성**: 촌수계산 인터페이스의 복잡성
  - *대응*: 직관적이고 간단한 UI 설계
- **결과 이해도**: 촌수 결과의 이해 어려움
  - *대응*: 명확한 설명 및 시각적 표현

---

## 7. 성공 기준

### 7.1 기능적 성공 기준
- ✅ **정확성**: 실제 가족 관계와 일치하는 촌수 계산
- ✅ **완전성**: 모든 관계 유형에 대한 촌수 계산 가능
- ✅ **성능**: 1초 이내 촌수 계산 완료
- ✅ **안정성**: 오류 없이 안정적 동작

### 7.2 사용자 경험 성공 기준
- ✅ **직관성**: 사용자가 쉽게 이해하고 사용 가능
- ✅ **편의성**: 최소한의 클릭으로 촌수 계산 가능
- ✅ **명확성**: 촌수 결과가 명확하게 표시됨
- ✅ **일관성**: 기존 UI와 일관된 디자인

---

## 8. 다음 단계

### 8.1 즉시 시작할 작업
1. **window.CORE_DATA 구조 분석**
2. **기존 함수 목록 정리**
3. **촌수계산 알고리즘 상세 설계**
4. **개발 환경 설정**

### 8.2 승인 요청사항
- **개발 계획 승인**: 조대표님의 계획 검토 및 승인
- **우선순위 확인**: 다른 기능 대비 촌수계산 기능의 우선순위
- **리소스 할당**: 개발에 필요한 시간 및 리소스 확인

---

**계획서 작성 완료**: 2025년 9월 14일  
**다음 단계**: 조대표님의 계획 검토 및 승인 후 개발 시작
