# 개인별 세부정보 표시모듈 작동절차와 기능

**문서 번호**: 046  
**작성일**: 2025년 9월 14일  
**작성자**: 서대리 (AI Assistant)  
**검토자**: 조대표님  
**버전**: 1.0  
**적용범위**: 한양조씨 족보앱 개인 세부정보 표시 기능

---

## 📋 **문서 개요**

### **목적**
- 개인별 세부정보 표시모듈의 작동 절차와 기능 상세 문서화
- V2.0 방법론에 따른 표준화된 세부정보 표시 방식 정의
- 향후 모든 개인 세부정보 표시 시 적용할 표준 모듈 가이드

### **배경**
- 4단계에서 완성된 개인 세부정보 표시 기능
- V4.0 단일소스 시스템 기반 데이터 접근
- 규격화된 가족관계 표시 순서 및 역방향 검색 기능

---

## 🎯 **모듈 개요**

### **핵심 파일**
- **`js/detail.js`**: 개인 세부정보 표시 전용 모듈
- **데이터 소스**: `window.CORE_DATA` (V4.0 단일소스 시스템)
- **표시 방식**: 규격화된 순서로 가족관계 표시

### **주요 기능**
1. **기본 정보 표시**: 이름, 세대, Line, 생년, 나이, 생존상태
2. **가족관계 표시**: 배우자, 부모, 자녀, 자녀의 배우자
3. **연락처 정보 표시**: 전화번호, 이메일, 주소
4. **추가 정보 표시**: 직업, 학력, 비고
5. **역방향 검색**: 자녀 필드가 없어도 부모 필드로 자녀 찾기

---

## 🔄 **작동 절차**

### **1단계: 페이지 초기화**
```javascript
// 페이지 로드 시 자동 실행
document.addEventListener('DOMContentLoaded', () => {
  initDetailPage();
});

function initDetailPage() {
  console.log("상세 정보 페이지 초기화");
  
  // 1. URL에서 인물 ID 가져오기
  const personId = getPersonIdFromUrl();
  if (!personId) {
    showError('인물 정보를 찾을 수 없습니다.');
    return;
  }
  
  // 2. 데이터 로드
  loadDetailData();
  
  // 3. 인물 정보 표시
  displayPersonDetail(personId);
  
  // 4. 앱 버전 정보 표시
  displayAppVersion();
}
```

### **2단계: 데이터 로드**
```javascript
function loadDetailData() {
  // V4.0 단일소스 시스템: window.CORE_DATA 사용
  detailData = window.CORE_DATA || CORE_DATA;
  console.log("상세 정보 데이터 로드 완료:", detailData);
}
```

### **3단계: 인물 상세 정보 표시**
```javascript
function displayPersonDetail(personId) {
  // 1. 인물 정보 조회
  const person = getPersonById(personId);
  if (!person) {
    showError('인물 정보를 찾을 수 없습니다.');
    return;
  }
  
  currentPerson = person;
  console.log("인물 상세 정보 표시:", person);
  
  // 2. 기본 정보 표시
  displayBasicInfo(person);
  
  // 3. 가족 관계 표시 (핵심 기능)
  displayFamilyRelations(person);
  
  // 4. 연락처 정보 표시
  displayContactInfo(person);
  
  // 5. 추가 정보 표시
  displayAdditionalInfo(person);
}
```

---

## 📊 **세부 기능별 작동 절차**

### **1. 기본 정보 표시 (`displayBasicInfo`)**

#### **표시 순서:**
1. **이름**: `person.name`
2. **생존상태**: `person.생존상태` (생존/고인)
3. **세대**: `person.세대`세대
4. **Line**: `person.Line1`
5. **생년**: `person.생년` (미상 표시)
6. **나이**: `person.age`세 (미상 표시)

#### **코드 구현:**
```javascript
function displayBasicInfo(person) {
  // 헤더 정보
  document.getElementById('person-name').textContent = person.name;
  
  // 상태 표시 (생존/고인)
  const statusElement = document.getElementById('person-status');
  statusElement.textContent = person.생존상태 === '생존' ? '생존' : '고인';
  statusElement.className = `person-status ${person.생존상태 === '생존' ? 'living' : 'deceased'}`;
  
  // 기본 정보
  document.getElementById('person-generation').textContent = `${person.세대}세대`;
  document.getElementById('person-line').textContent = person.Line1;
  document.getElementById('person-birth').textContent = person.생년 || '미상';
  document.getElementById('person-age').textContent = person.age ? `${person.age}세` : '미상';
}
```

### **2. 가족관계 표시 (`displayFamilyRelations`) - 핵심 기능**

#### **표시 순서 (V5.0 규격화):**
1. **배우자** (본인의 배우자)
2. **부** (아버지)
3. **모** (어머니)
4. **아들** (자녀 중 남성)
5. **아들의 배우자** (아들이 기혼인 경우)
6. **딸** (자녀 중 여성)
7. **딸의 배우자** (딸이 기혼인 경우)

#### **역방향 검색 알고리즘:**
```javascript
// 자녀 찾기 함수 (핵심 혁신)
function findChildrenByParent(parentName) {
  return detailData?.persons?.filter(person => 
    person.relationships.father === parentName || 
    person.relationships.mother === parentName
  ) || [];
}
```

#### **가족관계 표시 코드:**
```javascript
function displayFamilyRelations(person) {
  const familyList = document.getElementById('family-list');
  const relations = [];
  
  console.log('가족관계 표시 시작 (V5.0):', person.name);
  
  // 1. 배우자 (본인의 배우자)
  if (person.relationships.spouses && person.relationships.spouses.length > 0) {
    person.relationships.spouses.forEach(spouseName => {
      const spouse = getPersonByName(spouseName);
      if (spouse) {
        relations.push({
          relation: '배우자',
          name: spouse.name,
          생존상태: spouse.생존상태,
          id: spouse.id
        });
      }
    });
  }
  
  // 2. 부 (아버지)
  if (person.relationships.father) {
    const father = getPersonByName(person.relationships.father);
    if (father) {
      relations.push({
        relation: '부',
        name: father.name,
        생존상태: father.생존상태,
        id: father.id
      });
    }
  }
  
  // 3. 모 (어머니)
  if (person.relationships.mother) {
    const mother = getPersonByName(person.relationships.mother);
    if (mother) {
      relations.push({
        relation: '모',
        name: mother.name,
        생존상태: mother.생존상태,
        id: mother.id
      });
    }
  }
  
  // 4-7. 자녀 및 자녀의 배우자 (역방향 검색)
  const children = findChildrenByParent(person.name);
  
  // 아들들 먼저 표시
  const sons = children.filter(child => child.성별 === 'M');
  sons.forEach(son => {
    // 아들 표시
    relations.push({
      relation: '아들',
      name: son.name,
      생존상태: son.생존상태,
      id: son.id
    });
    
    // 아들의 배우자 표시 (기혼인 경우)
    if (son.relationships.spouses && son.relationships.spouses.length > 0) {
      son.relationships.spouses.forEach(spouseName => {
        const spouse = getPersonByName(spouseName);
        if (spouse) {
          relations.push({
            relation: '아들의 배우자',
            name: spouse.name,
            생존상태: spouse.생존상태,
            id: spouse.id
          });
        }
      });
    }
  });
  
  // 딸들 표시
  const daughters = children.filter(child => child.성별 === 'F');
  daughters.forEach(daughter => {
    // 딸 표시
    relations.push({
      relation: '딸',
      name: daughter.name,
      생존상태: daughter.생존상태,
      id: daughter.id
    });
    
    // 딸의 배우자 표시 (기혼인 경우)
    if (daughter.relationships.spouses && daughter.relationships.spouses.length > 0) {
      daughter.relationships.spouses.forEach(spouseName => {
        const spouse = getPersonByName(spouseName);
        if (spouse) {
          relations.push({
            relation: '딸의 배우자',
            name: spouse.name,
            생존상태: spouse.생존상태,
            id: spouse.id
          });
        }
      });
    }
  });
  
  console.log('최종 가족관계 목록 (V5.0):', relations);
  
  // 가족 관계 HTML 생성 (클릭 가능하도록 수정)
  if (relations.length === 0) {
    familyList.innerHTML = '<div class="empty-state"><div class="empty-icon">👨‍👩‍👧‍👦</div><div class="empty-text">가족 관계 정보가 없습니다.</div></div>';
  } else {
    familyList.innerHTML = relations.map(relation => 
      `<div class="family-item" onclick="showPersonDetail('${relation.id}')">
        <div class="family-relation">${relation.relation}</div>
        <div class="family-name">${relation.name}</div>
        <div class="family-status ${relation.생존상태 === '생존' ? 'living' : 'deceased'}">${relation.생존상태 === '생존' ? '생존' : '고인'}</div>
      </div>`
    ).join('');
  }
}
```

### **3. 연락처 정보 표시 (`displayContactInfo`)**

#### **표시 항목:**
- **전화번호**: `person.contact.phone`
- **이메일**: `person.contact.email`
- **주소**: `person.contact.address`

#### **코드 구현:**
```javascript
function displayContactInfo(person) {
  const contactList = document.getElementById('contact-list');
  const contacts = [];
  
  if (person.contact.phone) {
    contacts.push({
      icon: '📞',
      label: '전화번호',
      value: person.contact.phone
    });
  }
  
  if (person.contact.email) {
    contacts.push({
      icon: '📧',
      label: '이메일',
      value: person.contact.email
    });
  }
  
  if (person.contact.address) {
    contacts.push({
      icon: '🏠',
      label: '주소',
      value: person.contact.address
    });
  }
  
  contactList.innerHTML = contacts.map(contact => 
    `<div class="contact-item">
      <div class="contact-icon">${contact.icon}</div>
      <div class="contact-info">
        <div class="contact-label">${contact.label}</div>
        <div class="contact-value">${contact.value}</div>
      </div>
    </div>`
  ).join('');
}
```

### **4. 추가 정보 표시 (`displayAdditionalInfo`)**

#### **표시 항목:**
- **직업**: `person.additional.job`
- **학력**: `person.additional.education`
- **비고**: `person.additional.notes`

#### **코드 구현:**
```javascript
function displayAdditionalInfo(person) {
  const additionalInfo = document.getElementById('additional-info');
  const additional = person.additional;
  
  const additionalItems = [];
  
  if (additional.job) {
    additionalItems.push({
      label: '직업',
      value: additional.job
    });
  }
  
  if (additional.education) {
    additionalItems.push({
      label: '학력',
      value: additional.education
    });
  }
  
  if (additional.notes) {
    additionalItems.push({
      label: '비고',
      value: additional.notes
    });
  }
  
  additionalInfo.innerHTML = additionalItems.map(item => 
    `<div class="additional-item">
      <div class="additional-label">${item.label}</div>
      <div class="additional-value">${item.value}</div>
    </div>`
  ).join('');
}
```

---

## 🔧 **유틸리티 함수들**

### **1. 인물 조회 함수들**
```javascript
// ID로 인물 조회
function getPersonById(id) {
  return detailData?.persons?.find(p => p.id === id);
}

// 이름으로 인물 조회
function getPersonByName(name) {
  return detailData?.persons?.find(p => p.name === name);
}
```

### **2. 역방향 검색 함수**
```javascript
// 자녀 찾기 함수 (핵심 혁신)
function findChildrenByParent(parentName) {
  return detailData?.persons?.filter(person => 
    person.relationships.father === parentName || 
    person.relationships.mother === parentName
  ) || [];
}
```

### **3. URL 처리 함수**
```javascript
// URL에서 인물 ID 추출
function getPersonIdFromUrl() {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get('id');
}
```

### **4. 앱 버전 표시 함수**
```javascript
function displayAppVersion() {
  const appVersion = document.getElementById('app-version');
  const dataVersion = document.getElementById('data-version');
  
  if (appVersion && dataVersion && detailData) {
    appVersion.textContent = detailData.config.app.version;
    dataVersion.textContent = detailData.config.app.dataVersion;
  }
}
```

---

## 🎯 **핵심 특징 및 혁신사항**

### **1. V4.0 단일소스 시스템**
- **데이터 소스**: `window.CORE_DATA`만 사용
- **일관성**: 모든 필드명이 노션과 완전 일치
- **안정성**: 데이터 불일치 문제 완전 해결

### **2. 역방향 검색 알고리즘**
- **혁신**: 자녀 필드가 없어도 부모 필드로 자녀 찾기
- **효율성**: 동적 가족관계 표시
- **확장성**: 새로운 가족관계 자동 인식

### **3. 규격화된 표시 순서**
- **일관성**: 모든 개인에게 동일한 순서로 표시
- **직관성**: 배우자 → 부모 → 자녀 → 자녀의 배우자
- **완전성**: 기혼 여부에 따른 조건부 배우자 표시

### **4. 클릭 가능한 가족관계**
- **사용성**: 가족관계 클릭 시 해당 인물 상세정보로 이동
- **연결성**: 가족관계 탐색의 연속성 제공
- **직관성**: 사용자 친화적 인터페이스

---

## 📋 **적용 가이드**

### **새로운 개인 세부정보 표시 시 적용 방법**

#### **1. 필수 파일 포함**
```html
<!-- HTML 파일에 필수 스크립트 포함 -->
<script src="../data/core_browser.js"></script>
<script src="js/detail.js"></script>
```

#### **2. 필수 HTML 구조**
```html
<!-- 기본 정보 표시 영역 -->
<div id="person-name"></div>
<div id="person-status"></div>
<div id="person-generation"></div>
<div id="person-line"></div>
<div id="person-birth"></div>
<div id="person-age"></div>

<!-- 가족관계 표시 영역 -->
<div id="family-list"></div>

<!-- 연락처 정보 표시 영역 -->
<div id="contact-list"></div>

<!-- 추가 정보 표시 영역 -->
<div id="additional-info"></div>

<!-- 앱 버전 정보 -->
<div id="app-version"></div>
<div id="data-version"></div>
```

#### **3. URL 파라미터 형식**
```
detail.html?id=G4M131S
```

#### **4. 데이터 구조 요구사항**
```javascript
// window.CORE_DATA 구조
{
  persons: [
    {
      id: "G4M131S",
      name: "조은상",
      세대: 4,
      성별: "M",
      Line1: "Line1",
      생년: "1985",
      생존상태: "생존",
      relationships: {
        father: "조동하",
        mother: "라은실",
        spouses: ["변주란"]
      },
      contact: {
        phone: "010-1234-5678",
        email: "example@email.com",
        address: "서울시 강남구"
      },
      additional: {
        job: "회사원",
        education: "대학교 졸업",
        notes: "비고사항"
      }
    }
  ]
}
```

---

## 🚨 **주의사항 및 제약조건**

### **1. 데이터 소스 제약**
- **필수**: `window.CORE_DATA`가 로드되어 있어야 함
- **일관성**: 모든 필드명이 노션과 일치해야 함
- **완전성**: 필수 필드(이름, 세대, 성별, Line1, 생존상태)가 있어야 함

### **2. 가족관계 표시 제약**
- **역방향 검색**: 자녀는 부모 필드로만 찾을 수 있음
- **배우자 표시**: 기혼인 경우에만 배우자 표시
- **순서 고정**: 표시 순서는 변경하지 말 것

### **3. 성능 고려사항**
- **데이터 크기**: 152명 데이터 기준으로 최적화됨
- **검색 효율성**: `find()` 함수 사용으로 O(n) 복잡도
- **메모리 사용**: 전체 데이터를 메모리에 로드

---

## 📊 **테스트 및 검증**

### **1. 기능 테스트**
- ✅ **기본 정보 표시**: 이름, 세대, Line, 생년, 나이, 생존상태
- ✅ **가족관계 표시**: 배우자, 부모, 자녀, 자녀의 배우자
- ✅ **역방향 검색**: 조은상의 자녀(조광희, 조수정) 정확히 찾기
- ✅ **클릭 기능**: 가족관계 클릭 시 상세정보 이동
- ✅ **연락처 표시**: 전화번호, 이메일, 주소
- ✅ **추가 정보 표시**: 직업, 학력, 비고

### **2. 데이터 일치성 테스트**
- ✅ **노션 데이터**: 152명 완전 동기화
- ✅ **필드명 일치**: 100% 일치
- ✅ **가족관계 정확성**: 역방향 검색으로 자녀 정확히 찾기

### **3. 사용자 경험 테스트**
- ✅ **로딩 속도**: 빠른 데이터 로드
- ✅ **표시 순서**: 직관적인 가족관계 표시
- ✅ **클릭 반응**: 즉시 상세정보 이동
- ✅ **오류 처리**: 데이터 없을 시 적절한 메시지 표시

---

## 🎯 **결론**

### **핵심 성과**
1. **V4.0 단일소스 시스템** 기반 안정적인 데이터 접근
2. **역방향 검색 알고리즘**으로 자녀 자동 찾기 기능
3. **규격화된 가족관계 표시** 순서 및 방식
4. **클릭 가능한 가족관계**로 연속적인 탐색 가능
5. **완전한 개인 정보 표시** (기본정보, 가족관계, 연락처, 추가정보)

### **적용 범위**
- **현재**: 4단계 개인검색 기능에서 사용 중
- **향후**: 모든 개인 세부정보 표시 시 표준 모듈로 사용
- **확장**: 새로운 가족관계나 정보 추가 시에도 동일한 구조 적용

### **의의**
이 모듈은 **V2.0 방법론**의 핵심 원칙인 "하나의 소스", "함수 재활용", "레고블록 독립성"을 완벽하게 구현한 표준 모듈입니다. 향후 모든 개인 세부정보 표시 시 이 모듈을 기준으로 하여 일관성과 안정성을 보장할 수 있습니다.

---

**작성 완료일**: 2025년 9월 14일  
**다음 검토 예정일**: 조대표님 검토 후  
**관련 문서**: 045번 4단계 개인검색 기능 완료 보고서, 039번 개발방법론 V2.0
