노션-앱 데이터 동기화 전략
작성일: 2025.09.12
 작성자: 노팀장
 목적: 마스터 데이터(노션) ↔ 앱 데이터(JSON) 동기화 방안

🔄 동기화 아키텍처 선택
방안 A: 노션 마스터 + 단방향 동기화 (권장)
데이터 플로우
노션(마스터) → JSON 생성 → 앱 배포
     ↑
관리자 수정/사용자 요청 처리

특징
노션 = 마스터 DB: 모든 진실의 원천
JSON = 읽기 전용: 앱에서는 조회만
수정 = 노션을 통해: 관리자가 노션에서 직접 수정
배포 = 수동: 노션 변경 → JSON 재생성 → 앱 업데이트
장점
데이터 일관성 보장
노션 MCP 활용 극대화
단순한 아키텍처
족보 무결성 보장
단점
실시간 동기화 불가
사용자 수정 시 지연
관리자 개입 필요

방안 B: 양방향 동기화 (복잡)
데이터 플로우
노션(마스터) ↔ 동기화 서버 ↔ 앱(JSON)

특징
실시간 동기화: 양방향 자동 동기화
충돌 해결: 복잡한 충돌 처리 로직 필요
서버 필요: 중간 동기화 서버 구축
장점
실시간 업데이트
사용자 편의성 극대화
단점
복잡한 아키텍처
서버 비용 발생
데이터 충돌 위험
MVP 범위 초과

💡 추천 전략: 하이브리드 방식
기본 원칙
노션 = 마스터 데이터
앱 = 캐시 + 임시 수정
주기적 동기화
구체적 워크플로우
1. 사용자 개인 정보 수정
사용자 앱에서 수정 → 임시 저장(로컬) → 관리자 승인 요청
→ 관리자 노션 수정 → JSON 재생성 → 앱 업데이트

2. 관리자 직접 수정
관리자 노션 수정 → JSON 재생성 → 앱 업데이트 배포

3. 주기적 배치 동기화
매일/매주 → 노션 변경 감지 → JSON 재생성 → 자동 배포


📱 앱 레벨 구현 방안
데이터 레이어 구조
┌─ Local Storage ─┐    ┌─ Remote JSON ─┐    ┌─ Notion DB ─┐
│  임시 수정사항    │    │   읽기 전용    │    │  마스터 DB   │
│  사용자 설정     │ ↔  │   캐시 데이터   │ ← │  관리자 수정  │
│  오프라인 지원    │    │   앱 배포용    │    │  진실의 원천  │
└─────────────────┘    └──────────────┘    └─────────────┘

수정 권한별 처리 방식
즉시 수정 가능 (본인+배우자+자녀)
function updatePersonalInfo(data) {
  // 1. 로컬에 즉시 반영
  localStorage.setItem('personalUpdates', data);
  
  // 2. 관리자에게 알림
  sendNotificationToAdmin(data);
  
  // 3. 다음 동기화 때 노션 반영
  scheduleSync();
}

관리자 승인 필요
function requestDataUpdate(data) {
  // 1. 수정 요청 저장
  localStorage.setItem('pendingRequests', data);
  
  // 2. 관리자에게 승인 요청
  sendApprovalRequest(data);
  
  // 3. 승인 후 노션 반영
}


⚙️ 동기화 메커니즘
버전 관리 시스템
{
  "dataVersion": "1.2.3",
  "lastSync": "2025-09-12T10:30:00Z",
  "pendingChanges": 5,
  "localModifications": {
    "p_023": {
      "field": "phone",
      "oldValue": "010-1111-1111", 
      "newValue": "010-2222-2222",
      "timestamp": "2025-09-12T09:15:00Z",
      "status": "pending"
    }
  }
}

동기화 트리거
자동 트리거
앱 시작: 버전 체크 후 필요시 업데이트
주기적 체크: 매 시간마다 버전 확인
Push 알림: 서버에서 업데이트 알림
수동 트리거
새로고침: 사용자가 수동으로 동기화
설정에서: "최신 데이터 가져오기" 버튼
충돌 해결 규칙
노션 우선: 충돌 시 노션 데이터가 우선
사용자 알림: 충돌 발생 시 사용자에게 알림
백업 보관: 덮어쓰기 전 로컬 변경사항 백업

🔄 실제 동기화 프로세스
1단계: 노션 → JSON 변환
// Claude 온라인에서 실행
async function syncNotionToJSON() {
  // 1. 노션 데이터 조회
  const notionData = await queryNotionDatabase();
  
  // 2. JSON 형태로 변환
  const jsonData = convertToAppFormat(notionData);
  
  // 3. 버전 번호 증가
  const newVersion = incrementVersion();
  
  // 4. JSON 파일 생성
  const result = {
    version: newVersion,
    timestamp: new Date().toISOString(),
    data: jsonData
  };
  
  return result;
}

2단계: 앱 배포 업데이트
// 앱에서 실행
async function checkForUpdates() {
  // 1. 현재 버전 확인
  const currentVersion = localStorage.getItem('dataVersion');
  
  // 2. 서버 버전 확인
  const serverVersion = await fetch('/api/version');
  
  // 3. 업데이트 필요 시 다운로드
  if (needsUpdate(currentVersion, serverVersion)) {
    const newData = await fetch('/api/data.json');
    updateLocalData(newData);
  }
}


📊 동기화 주기별 전략
실시간 (즉시)
개인 정보 수정: 로컬 즉시 반영
사용자 설정: 앱 내에서 즉시
준실시간 (1시간 이내)
관리자 승인: 노션 수정 → JSON 재생성
긴급 업데이트: 중요한 변경사항
배치 처리 (일일/주간)
정기 동기화: 매일 자정 자동 동기화
대량 업데이트: 많은 변경사항 일괄 처리
수동 (필요시)
사용자 요청: "새로고침" 버튼
관리자 강제: 즉시 동기화 실행

🎯 사용자 시나리오 영향
수정된 사용자 경험
개인 정보 수정 시나리오
1. 사용자: "전화번호 변경" 
   → 앱에서 즉시 변경 (로컬)
   
2. 시스템: "변경사항이 저장되었습니다" 
   → "관리자 승인 후 모든 사용자에게 반영됩니다"
   
3. 관리자: 노션에서 승인 및 수정
   
4. 시스템: 다음 동기화 시 모든 앱에 반영

데이터 불일치 처리
1. 사용자A: 조광희님 전화번호 수정 (로컬)
2. 관리자: 동시에 노션에서 다른 정보 수정
3. 동기화: 충돌 감지
4. 시스템: 사용자A에게 알림 + 선택 옵션 제공
5. 해결: 노션 데이터 우선 + 사용자 재확인


⚡ MVP 단계 구현 전략
Phase 1: 단방향 동기화
노션 → JSON → 앱 (읽기 전용)
수정 요청은 관리자 문의로 처리
주기적 수동 JSON 업데이트
Phase 2: 하이브리드 동기화
개인 정보 로컬 수정 기능 추가
관리자 승인 프로세스 구현
자동 버전 체크 기능
Phase 3: 준실시간 동기화
관리자 승인 시 즉시 JSON 재생성
Push 알림으로 업데이트 통지
충돌 해결 UI 구현
추천: Phase 1으로 MVP 시작하여 복잡성 최소화 후 점진적 발전
다음 단계: 선택한 동기화 전략을 반영한 데이터 스키마 수정

